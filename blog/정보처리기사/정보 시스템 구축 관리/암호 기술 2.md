태그: #정보처리기사 
연결문서: [암호 기술 3](암호%20기술%203.md)

# 01. 암호 기술

## 03. 대칭키 암호화 공개키 암호

### 1) 대칭키 암호화 공개키 암호

#### 1. 대칭키 암호화 방식
- 암호화 키와 복호화 키가 동일함
- 송신 측과 수신 측이 통신하기 전에 키를 분해하고 보관하고 있어야 함
- 송수신 측 모두가 키를 비밀리에 보관하고 있어야 함
- 키 분배가 공개키 암호화 방식에 비해 어려움
- 대칭키(비밀키) 암호화 방식은 공개키 암호화 방식보다 단순하고 암호화 속도가 빠름
- 대칭키(비밀키) 암호화 방식은 데이터를 변환하는 방법에 따라 블록 암호와 스트림 암호로 구분됨
- 비밀키, 관용키, 단일키 암호화 방식이라고도 함
- DES(Data Encryption Standard)가 가장 대표적인 알고리즘

#### 2. 공개키 암호화 방식
- 암호화 키와 복호화 키가 다름
- 암호화 키와 복호화 키를 생성하여 암호화 키는 공개하고, 복호화 키는 비밀리에 보관하고 있어야 함
- 키 분배가 비밀키 암호화 방식보다 용이함
- 송신 측은 수신 측에서 보내온 공개키로 평문을 암호화하여 전송하면 수신 측은 비밀리에 보관하고 있던 복호화 키를 이용하여 암호문을 평문으로 복호화함
- 공개키 암호화 방식은 비밀키 암호화 방식과 달리 암호화 키를 사전에 전송할 필요가 없으므로 불특정 다수 사이에서 암호화된 통신망을 구축할 때 용이함
- 공개키 암호화 방식은 비밀키 암호화 방식에 비해 복잡하고 암호화 속도가 느림
- 공개키 암호화 방식은 알고리즘과 공개키를 알아도 개인키를 알아내는 것이 매우 어려움
- 디지털 서명에 적합함
- RSA가 가장 대표적인 알고리즘
- 비대칭키, 공용키 방식이라고도 함

<br>

### 2) 공개키 기반 구조(PKI : Public Key Infrastructure)
- 네트워크 환경에서 보안 요구사항을 만족시키기 위해 공개키 암호화 인증서 사용을 가능하게 해 주는 기반 구조
- 공개키 암호화 방식을 안전하게 사용하고 관리하기 위한 정보보호 방식
- 공개키 암호화 방식을 바탕으로 한 인증서를 활용하는 소프트웨어, 하드웨어, 정책 및 규칙 등을 총칭함
- 공개키 암호화 방식을 이용하여 송수신 데이터를 암호화하고, 보유한 암호를 이용하여 거래자 신원을 확인하는 방식의 사용자 인증 시스템
- 공개키 암호화 방식을 통한 암호화 및 전자서명을 제공하는 복합적인 보안 시스템 환경
- 공개키 암호화 방식을 이용하여 송수신 데이터를 암호화하고 디지털인증서를 통해 사용자를 인증하는 시스템
- 공개키 기반 구조는 인터넷 뱅킹, 전자화폐, 전자서명, 인터넷 쇼핑, 항공 예약, 열차 예약, 공연 예약, 전자우편 등에 응용됨

<br>

### 3) 공개키 기반 구조의 디지털 인증서
- 전자서명의 신분을 확인하기 위해 인증서를 사용함
- 인증서는 실세계에서 사용한 인감도장을 증명할 수 있는 인감증명서를 첨부하는 것과 같은 역할을 함
- 공개키 인증서를 발행하여 기밀성, 무결성, 인증, 부인방지, 접근 제어를 보장함
- 인증서는 쌍방 간의 거래를 증명해줄 수 있는 제 3의 기관(공인인증기관)에서 발부해야 함
- 공개키 기반 구조의 구성 요소로는 공개키 인증서, 공인인증기관, 등록기관, 디렉터리, 사용자 등이 있음
- 공인인증기관(CA : Certification Authority)은 공공성을 지니며 신뢰할 수 있는 기관으로 인증 업무를 수행함
- 공인인증기관(CA)은 사용자에 대한 공개키 인증서를 생성하고 이를 발급함
- 공인인증기관(CA)은 인증설흘 발행하며, 등록 기관(RA : Registration Authority)은 인증서 신청자의 신원 확인 및 인증서 등록을 대행함
- 공인인증기관(CA)은 필요 시 사용자 인증에서 대한 갱신 및 폐기 기능을 수행함
- 공인인증기관(CA)은 인증서 폐기목록(CRL : Certification Revocation List)을 작성함
- 공인인증서의 폐지 여부는 인증서폐지목록(CRL)과 온라인 인증서 상태 프로토콜(OCSP) 확인을 통해서 이루어짐
- 공인인증서는 버전, 일련번호, 서명, 발급자, 유효기관 등의 데이터 구조를 포함하고 있음(인증서 규정 X.509)

<br>

### 4) 공개키와 개인키 암호화의 동작 원리
- 암호화된 메시지를 송신할 때에는 수신자의 공개키를 사용하며, 암호화된 서명 송신 시에는 송신자의 개인키를 사용함
- 암호화된 메시지를 수신할 때에는 수신자의 개인키를 사용하며, 암호화된 서명 수신 시에는 송신자의 공개키를 사용함

| &nbsp;&nbsp;작업&nbsp;&nbsp; | &nbsp;&nbsp;송수신측&nbsp;&nbsp; | &nbsp;&nbsp;키사용&nbsp;&nbsp; |
| :-: | :-: | :-: |
| &nbsp;&nbsp;암호화된 메시지 송신&nbsp;&nbsp; | &nbsp;&nbsp;수신자&nbsp;&nbsp; | &nbsp;&nbsp;공개키&nbsp;&nbsp; |
| &nbsp;&nbsp;암호화된 서명 송신&nbsp;&nbsp; | &nbsp;&nbsp;송신자&nbsp;&nbsp; | &nbsp;&nbsp;개인키&nbsp;&nbsp; |
| &nbsp;&nbsp;암호화된 메시지 수신&nbsp;&nbsp; | &nbsp;&nbsp;수신자&nbsp;&nbsp; | &nbsp;&nbsp;개인키&nbsp;&nbsp; |
| &nbsp;&nbsp;암호화된 서명 수신&nbsp;&nbsp; | &nbsp;&nbsp;송신자&nbsp;&nbsp; | &nbsp;&nbsp;공개키&nbsp;&nbsp; |

<br>

### 5) 공개키 암호 방식을 이용한 전자서명 순서

```md
A가 B에게 전자서명된 메시지를 전송하는 과정

1. A와 B는 개인키와 공용키의 쌍을 각각 생성함
2. A는 A의 개인키를 사용하여 암호화된 메시지를 B에게 전송함
3. B는 A의 공개키를 사용하여 수신된 메시지를 해독함
```

- 송신자는 자신의 개인키로 서명하고 수신자는 송신자의 공개키로 서명을 검증함
- 전자서명은 사용자 인증, 무결성, 부인방지 기능을 제공하는 것이지 기밀성을 지키기 위한 것은 아님
- 기밀성이 필요하다면 메시지 자체를 별도의 암호화를 행해서 전달해야 함
- 메시지로부터 얻은 일정 크기의 해시값을 서명에 이용함
- 공개키 기반 전자서명에서 메시지에 서명하지 않고 메시지의 해시값과 같은 메시지 다이제스트에 서명함
- 메시지 다이제스트에 서명하는 이유는 공개키 암호화에 따른 성능 저하를 극복하기 위한 것

<br>

### 6) 하이브리드 암호 방식
- 대칭키 암호 시스템과 공개키 암호 시스템의 장점을 조합한 것
- 문서는 대칭키 암호화 시스템을 사용하고, 문서를 암호화하거나 복호화할 때 사용하는 키는 공개키 암호화 시스템을 사용함
- 하이브리드 암호 시스템을 사용하여 송신자가 수신자에게 문서를 보낼 때의 과정 순서
    1. 키를 사용하여 문서를 암호화할 때 -> 대칭키 암호 시스템
    2. 문서를 암, 복호화하는 데 필요한 키를 암호화할 때 -> 공개키 암호 시스템
    3. 키를 사용하여 암호화된 문서를 복호화할 때 -> 대칭키 암호 시스템

<br>

### 7) 하드 코드된 암호화 키
- 암호화 키가 프로그램 소스에 상숫값으로 존재하여 암호화에 사용되는 경우
- 소스 파일이나 실행 파일이 유출되었을 경우 암호화 키도 같이 유출되어 공격의 대상이 될 수 있음
- 암호화 키는 별도로 암호화하여 저장하거나 매번 키로 입력하여 사용함

<br>

### 8) 해시(Hash) 함수

#### 1. 해시 함수의 정의
- 일정치 않은 길이의 평문이나 메시지 문자열을 고정된 길이의 문자열(평문 다이제스트)로 만들어주는 함수
- 다양한 길이의 평문을 보다 빨리 처리할 수 있도록 짧은 길이의 값이나 키로 변환하는 알고리즘을 수식으로 표현한 것
- 해시 함수의 평문(메시지) 입력을 가변 길이를 갖고 출력(평문 다이제스트, 해시값)은 고정 길이를 가짐

#### 2. 해시 함수의 필요성
디지털 서명 알고리즘의 서명 단위(212, 1024비트)가 제한되어 있기 때문에 긴 메시지나 평문을 사용하기 어렵기 때문에, 서명하기 위해서는 긴 메시지를 여러 개의 블록으로 분리하여 각각을 서명해야 함
메시지의 길이에 따라 계산의 형태나 횟수가 증가되어 높은 계산적 부담이 존재함
메시지가 긴 경우에 분할된 블록의 서명 용량이 늘어나게 되어 오버헤드가 발생함
메시지가 긴 경우에 분할된 각 블록은 안전할 수 있으나 전체 블록의 순서 재배치, 삭제 등에 대해서는 안전할 수 없음

#### 3. 일방향 해시 함수
- 해시 함수가 데이터의 무결성을 제공하고, 메시지 인증 알고리즘으로 사용될 경우 일방향 해시 함수라고 함
- 임의의 평문이나 메시지를 받아드려 고정 길이의 출력값을 생성하고, 출력값을 비교하여 무결성을 확인함
- 해시 함수
    - h = H(M)
    - M : 메시지나 평문, H : 해시 함수, h : 해시 코드

#### 4. 해시 함수 사용
- 수신 측에 전달할 메시지를 해시 함수(H)를 통해 해시 코드(h)를 생성하고, 해시 코드와 메시지를 결합함
- 해시 코드와 결합된 메시지를 암호화 알고리즘을 통해 암호문으로 만듦
- 암호문이 수신 측에 전달되면 복호화 알고리즘을 통해 복원되며 메시지와 해시 코드(h)가 존재함
- 수신된 메시지로 다시 해시 코드(h)를 구하고, 수신된 해시 코드와 비교하여 같으면 정상 수신한 것으로 판단함

#### 5. 해시 함수 조건
- 해시 함수는 다양한 길이의 메시지를 적용할 수 있어야 함
- 해시 함수는 고정된 길이의 출력을 만들어야 함
- 해시 함수는 계산하기 쉬워야 함
- 해시 함수와 해시 코드만 주어졌을 때 메시지를 복원하는 것이 불가능하도록 해야 함
- 해시 함수는 같은 출력을 갖는 두 입력을 찾기 어려워야 함

#### 6. 해시 함수의 특징 및 종류
- 해시 함수는 대칭키 암호나 공개키 암호와는 달리 키를 사용하지 않는 암호 알고리즘
- 해시 함수의 출력은 의사 난수여야 함
- 해시 함수는 전자서명 등에서의 메시지 압축, 키 생성, 의사 난수 생성(출력) 등에 널리 사용되는 암호학적 함수
- 해시 함수는 임의의 메시지를 입력으로 받아 고정된 길이의 비트열을 출력하는 다대일 함수
- 해시 함수는 다대일 대응 함수로 동일한 출력을 갖는 입력이 두 개 이상 존재하면 충돌이 발생함

| &nbsp;&nbsp;해시 함수&nbsp;&nbsp; | &nbsp;&nbsp;출력 비트&nbsp;&nbsp; | &nbsp;&nbsp;입력 비스&nbsp;&nbsp; | &nbsp;&nbsp;라운드&nbsp;&nbsp; | &nbsp;&nbsp;속도&nbsp;&nbsp; |
| :-: | :-: | :-: | :-: | :-: |
| &nbsp;&nbsp;MD4&nbsp;&nbsp; | &nbsp;&nbsp;128&nbsp;&nbsp; | &nbsp;&nbsp;512&nbsp;&nbsp; | &nbsp;&nbsp;48&nbsp;&nbsp; | &nbsp;&nbsp;1.00&nbsp;&nbsp; |
| &nbsp;&nbsp;MD5&nbsp;&nbsp; | &nbsp;&nbsp;128&nbsp;&nbsp; | &nbsp;&nbsp;512&nbsp;&nbsp; | &nbsp;&nbsp;64&nbsp;&nbsp; | &nbsp;&nbsp;0.68&nbsp;&nbsp; |
| &nbsp;&nbsp;RIPE-MD-128&nbsp;&nbsp; | &nbsp;&nbsp;128&nbsp;&nbsp; | &nbsp;&nbsp;512&nbsp;&nbsp; | &nbsp;&nbsp;128&nbsp;&nbsp; | &nbsp;&nbsp;0.39&nbsp;&nbsp; |
| &nbsp;&nbsp;RIPE-MD-160&nbsp;&nbsp; | &nbsp;&nbsp;160&nbsp;&nbsp; | &nbsp;&nbsp;512&nbsp;&nbsp; | &nbsp;&nbsp;160&nbsp;&nbsp; | &nbsp;&nbsp;0.24&nbsp;&nbsp; |
| &nbsp;&nbsp;SHA-1&nbsp;&nbsp; | &nbsp;&nbsp;160&nbsp;&nbsp; | &nbsp;&nbsp;512&nbsp;&nbsp; | &nbsp;&nbsp;80&nbsp;&nbsp; | &nbsp;&nbsp;0.28&nbsp;&nbsp; |

<br>

#### 7. MD5(Message-Digest algorithm 5)
- 미국 MIT 공과대학의 Ron Rivest에 의해 개발됨
- 가변 길이의 메시지를 고정된 길이인 128비트로 출력함
- 메시지는 512비트의 블록 단위로 처리함
- 마지막 블록에서 입력 메시지의 길이를 표현하기 위해 64비트를 할당함
- 패딩은 입력 메시지의 끝에 1을 넣고 나머지는 0으로 채움
- 패딩되는 비트의 범위는 1 ~ 512비트가 되며 원본의 메시지 길이가 부가(삽입)되도록 구성함
- MD5의 처리 속도는 512비트 입력 메싯지를 100만 수행한 결과가 0.68초 정도 걸림
- 8비트 상태에서 동작하는 4개의 버퍼 A, B, C, D의 초기 값을 부여함
- 4개의 버퍼는 32비트 워드로 되어 있음
- MD5 버퍼는 블록 데이터 처리 단계에서 연산되는 블록 데이터의 결과를 일시적이거나 최종적으로 보관하는 데 사용되며, 기억 장소는 레지스터
- 512비트 블록을 처리하는 단계에서는 4개의 라운드 처리로 16번 반복하므로 총 라운드 수는 64번
- 각 라운드는 비슷하지만 비선형 함수, 모듈러 덧셈, 회전 등을 사용함

#### 8. SHA-1(Secure Hash Algorithm 1)
- SHA 알고리즘은 NSA에 의해 설계된 알고리즘으로 미국 정부 표준
- MD4 알고리즘에 기반을 두고 있는 SHA는 입력 메시지는 512비트 블록, 출력은 고정된 160비트로 출력함
- 160비트의 5개의 버퍼를 초기화하여 사용하며 해시 함수의 초기 값과 최종 값을 저장하기 위해 사용되어짐
- SHA-1의 처리 속도는 512비트 입력 메시지를 100만 수행한 결과가 0.28초 정도 걸림
- 버퍼는 5개의 레지스터(A, B, C, D, E)로 표현되는데, 초기화되는 값은 다음과 같음
    - A = 0x67452301
    - B = 0xEFCDAB89
    - C = 0x98DADCFE
    - D = 0x10325476
    - E = 0xC3D2E1F0
- 512비트 블록을 처리하는 단계에서는 5개의 라운드 처리로 16번 반복하므로 총 라운드 수는 80번

####  9. 해시 함수의 분류
- 전용(추가, 분할, 반복 이용) 해시 함수 : MD4, MD5, SHA-1, RIPE-MD, HAS160, TIGER
- 블록 암호 기반(DES 기반) 해시 함수 : MDC-2, MDC-4, SEED, AES
- 모듈러 연산 기반 해시 함수 : MASH-1, MASH-2

#### 10. 해시 함수의 키 존재 여부에 따른 분류
- MDD(Manipulation Detection Code) : 키가 없는 해시 함수로 MD2, MD5, SHA 등이 있음
- MAC(Message Authentication Code) : 키가 있는 해시 함수로 CBC-MAC, HMAC 등이 있음

#### 11. 메시지 인증 코드(MAC : Message Authentication Code)
- MAC는 메시지와 송수신자만이 공유하는 비밀키를 입력 받아 생성되는 반면에 해시는 비밀키 없이 메시지로부터 만들어짐
- MAC는 메시지에 붙여지는 작은 데이터 블록을 생성하기 위해 공유되는 비밀키를 이용함
- MAC으로 막을 수 있는 두 가지 위협은 메시지 변경과 위장
- MAC을 이용한 인증 순서
    1. 송신자 A와 수신자 B는 사전에 키를 공유함
    2. 송신자 A는 송금 의뢰 메시지를 기초로 해서 MAC 값을 계산함
        - 공유하는 비밀키를 사용
    3. 송신자 A는 수신자 B에게 송금 의뢰 메시지와 MAC 값을 보냄
    4. 수신자 B는 수신한 송금 의뢰 메시지로 MAC 값을 계산함
        - 공유하는 비밀키를 사용
    5. 수신자 B는 송신자 A로부터 수신한 MAC 값과 계산으로 얻어진 MAC 값을 비교함
    6. 수신자 B는 2개의 MAC 값이 동일하면 송신자 A로부터 온 것이라고 판단(인증 성공)하며, 동일하지 않다면 송신자 A로부터 온 것이 아니라고 판단함(인증 실패)

#### 12. 암호화 해시 함수가 가져야 하는 성질
- 역상 저항성(Preimage Resistance)
    - 해시값으로부터 원래의 입력값과의 관계를 찾기 어려운 성질
    - 주어진 해시값에 대해, 그 해시값을 생성하는 입력값을 찾는 것이 어려움
    - 해시값을 이용하여 원래의 입력 메시지를 찾은 것은 계산상으로 불가능해야 함
    - 역상 저항성은 주어진 임의의 출력값 y에 대해 y = h(x)를 만족하는 입력값 x를 찾는 것이 계산적으로 불가능한 성질
    - y가 주어지고, h(x) = y인 x를 찾는 것이 어려운 성질(일방향성)
- 제 2 역상 저항성(Second Preimage Resistance)
    - 주이진 입력값과 그 입력값에 해당하는 해시값에 대해, 동일한 해시값을 생성하는 다른 입력값을 찾는 것이 어려움
    - 입력 메시지와 그 해시값이 주어졌을 때, 이와 동일한 해시값을 갖는 다른 메시지를 찾는 것은 계산상으로 불가능해야 함
    - 두 번째 역상 저항성은 입력값 x에 대해 h(x) = h(x')를 만족하는 다른 입력값 x'를 찾는 것이 계산적으로 불가능한 성질
    - h(x) = y인 x와 y가 주어지고 h(x') = y인 x'(≠x)를 찾는 것이 어려운 성질
- 충돌 저항성(Collision Resistance)
    - 같은 해시값을 생성하는 임의의 서로 다른 두 개의 입력값을 찾는 것이 어려움
    - 서로 다른 두 입력 메시지에 대해 같은 해시값이 나올 가능성은 있으나, 계산적으로 같은 해시값을 갖는 서로 다른 두 입력 메시지를 찾는 것은 불가능해야 함
    - 충돌 저항성은 h(x) = h(x')를 만족하는 두 입력값 x와 x'를 찾는 것이 계산적으로 불가능한 성질
    - h(x) = h(x')인 x, x'(≠x)를 찾는 것이 계산적으로 불가능한 성질
    - 충돌 저항성은 제 2 역상 저항성을 보장함