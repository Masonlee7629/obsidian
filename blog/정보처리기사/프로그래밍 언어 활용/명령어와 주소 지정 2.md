태그: #정보처리기사 
연결문서: [운영체제 1](운영체제%201.md)

# 02. 명령어 형식과 주소 지정

## 01. 명령어(Instruction) 형식

### 1) 명령어 형식의 이해
- 비트(Bit)는 그 개수만큼 많은 정보를 저장할 수 있으며, 용도에 따라 필드로 나눌 수 있음
- 필드의 수, 배치 방법, 각 필드에 포함되는 0과 1의 개수를 정의한 것을 명령어 형식이라고 함
- 명령어 형식에 따라 정보의 양이 달라지기 때문에 용도에 따라 적절하게 구성해야 함
- 명령어 형식은 연산 코드(Operation, 연산자)와 연산을 수행하는 대상인 오퍼랜드(Operand, 피연산자, 변수)로 구성됨
- 명령문은 프로그램을 구성하는 문장으로, 지시 사항을 처리하는 단위를 의미함

<br>

### 2) Operation(Op-Code)와 Operand의 비트 수
1. Operation(Op-Code)의 비트 수와 명령어 개수와의 관계식
    - 명령어의 개수 = 2<sup>Op-Code 비트 수</sup>
    - Op-Code가 1비트면 명령어 동작 수는 2개
    - Op-Code가 0이면 MOV, 1이면 ADD로 정하면 됨
    - Op-Code가 2비트면 명령어 동작 수는 4개
    - Op-Code가 2비트일 때, 00이면 MOV, 01이면 ADD, 10이면 SUB, 11이면 DIV로 정하면 됨
    - Op-Code를 3비트를 사용하면 2<sup>3</sup> = 8개의 명령어를 사용할 수 있음
2. Operand의 비트 수와 기억 장치 용량과의 관계식
    - 기억 장치 용량 = 2<sup>Operand 비트 수</sup>
    - 오퍼랜드가 1비트라고 하면, 기억장치 용량은 2<sup>12</sup> = 4096개

<br>

---

<br>

## 02. 명령어 형식의 종류

### 1) 0-주소 명령어
- 오퍼레이션만 있고, 오퍼랜드가 없는 명령어 형식
- 스택 구조에서 사용하는 명령어가 대부분
- 스택에서 사용하는 명령어는 PUSH, POP이 있음
- PUSH는 스택에 자료를 입력하는 명령으로, 미리 지정된 레지스터나  기억 장소에 있는 자료가 스택으로 입력됨
- POP은 스택에서 자료를 출력하는 명령으로, 미리 지정된 레지스터나 기억 장소에 있는 자료가 출력되어 이동됨

<br>

### 2) 1-주소 명령어
- 오퍼랜드가 1개 있는 명령어 형식
- 누산기(ACCumulator)를 사용하고 있는 명령어가 대부분
- 누산기를 사용하는 명령어 형식
    - LOAD A : 주기억 장치 A에 기억된 데이터를 ACC에 적재함
    - ADD B : 주기억 장치 B에 있는 데이터를 ACC에 기억된 데이터와 더하여 다시 ACC에 기억시킴
    - MUL C : 주기억 장치 C에 있는 데이터를 ACC에 기억된 데이터와 곱하여 다시 ACC에 기억시킴
    - STORE D : ACC에 기억되어 있는 데이터를 주기억 장치 D에 저장함

<br>

### 3) 2-주소 명령어
- 오퍼랜드가 2개 있는 명령어 형식
- 명령어 수행 시 두 개의 오퍼랜드를 대상으로 연산하며, 그 결과는 첫 번째 있는 오퍼랜드인 Operand-1에 기억됨
- 최종 결과가 Operand-1에 기억되므로 원래 기억하고 있던 Operand-1의 데이터는 잃어버림
- 2-주소 명령어를 사용하는 명령어의 형식
    - ADD A, B : A와 B를 더하여 그 결과를 A에 기억시킴
    - MUL C, D : C와 D를 곱하여 그 결과를 C에 기억시킴
    - MOV E, F : F에 기억된 데이터를 E에 기억시킴

<br>

### 4) 3-주소 명령어 형식
- 오퍼랜드가 3개 있는 명령어 형식
- 명령어 수행 시 Operand-1과 Operand-2를 대상으로 연산하며, 그 결과를 마지막에 있는 Operand-3에 기억시킴
- 최종 연산 수행 시 Operand-1, Operand-2, Operand-3에 있는 데이터는 잃어버리지 않고 모두 기억됨
- 3-주소 명령어를 사용하는 명령어의 형식
    - ADD A, B, C : A와 B를 더하여 그 결과를 C에 기억시킴
    - MUL D, E, F : D와 E를 곱하여 그 결과를 F에 기억시킴

<br>

---

<br>

## 03. 주소 지정 방식(Addressing Mode)

### 1) 주소 지정 방식
1. 주소 지정 방식의 이해
    - 컴퓨터에서 주소는 기억 장치의 위치 값을 의미하며 실제 데이터가 기억되어 있는 위치를 나타냄
2. 주소 지정 방식의 종류
    - 즉시 주소 지정
    - 직접 주소 지정
    - 간접 주소 지정
    - 계산에 의한 주소 지정
3. 주소 지정 방식의 접근 속도(빠른 순서)
    - 즉시 주소 -> 직접 주소 -> 계산에 의한 주소 -> 간접 주소

<br>

### 2) 즉시(Immediate) 주소 지정 방식
- Operand(주소 필드)에 주기억 장치나 레지스터의 주소가 아닌 실제 데이터가 있는 방식으로 명령이 즉시 수행됨
- 기억 장치에 접근하지 않기 때문에 기억 장치를 참조할 필요가 없음
- 메모리 참조 횟수가 0인 명령
- 레지스터에 초기치를 부여할 때 주로 사용함
- 수행 속도는 빠르지만 주소 필드에 실제 데이터를 넣어야 하므로 명령어 길이에 문제가 발생함
    - 주소 필드를 다양한 데이터의 길이에 맞게 동적으로 조절할 수 없음

<br>

### 3) 직접(Direct) 주소 지정 방식
- 주소 필드 위치에 기억 장치의 위치 값을 지정하는 방식
- 주소 필드에 색인 레지스터, 베이스 레지스터를 사용하지 않고 주소 필드에 있는 실제 데이터가 기억된 기억 장치 내의 주소가 되는 방식
- 기억 장치의 위치를 한 번 찾아가면 실제 데이터가 존재함
- 주소 필드는 고정 길이로 표현할 수 있기 때문에 주소 필드의 길이에 제약이 없음
- 간단하지만 기억 장치가 확장되거나 변경될 때 사용의 어려움이 있음

<br>

### 4) 간접(Indirect) 주소 지정 방식
- 주소 필드에 있는 값이 실제 데이터가 있는 위치 값을 직접 지정하지 않고 주소를 기억하고 있는 위치 또는 레지스터를 지정하는 방식
- 실제 데이터가 있는 위치로 접근하기 위해서 두 번의 기억 장소를 참조해야 함
- 주소 필드의 길이가 고정되어 있거나 짧은 경우라도 언제든 원하는 위치에 접근할 수 있다는 장점이 있음

<br>

### 5) 계산(Calculate) 주소 지정 방식
- 기억 장치의 상수 값이나 레지스터에 있는 값을 계산하여 실제 데이터가 있는 위치 값을 찾아가는 방식
- 실제 데이터가 들어갈 기억 장치의 위치를 지정할 때 명령어의 주소 부분에 있는 값과 특정 레지스터에 기억된 값을 더해서 지정하는 방식
- 실제 데이터가 있는 위치로 접근하기 위해서 한 번의 기억 장소를 참조함

<br>

### 6) 계산에 참여하는 레지스터
1. 인덱스 주소 지정(Index Register Addressing)
    - 동질형의 데이터 구조인 배열을 사용할 때 많이 사용하는 방식
    - 순차적인 주소 지정 등에 유리하며 주소 지정에 레지스터가 2개 사용되는 방식
    - 유효 번지 = Index Register + 주소 부분(Operand)
2. 상대 주소 지정(Relative Addressing)
    - 오퍼랜드에 주소 값과 프로그램 카운터(PC)에 들어 있는 값을 더해서 데이터가 있는 위치에 접근함
    - 명령어 자신의 위치를 기준으로 실제 데이터의 위치를 지정함
    - 데이터 영역의 배치와 프로그램 영역의 배치가 유사할 때 주로 사용되는 방식
    - 유효 번지 = 프로그램카운터(PC) + 주소 부분(Operand)
3. 베이스 레지스터(Base Register Addressing)
    - 오퍼랜드에 주소 값과 베이스 레지스터에 들어 있는 값을 더해서 데이터가 있는 위치에 접근함
    - 주기억 장치 내 프로그램의 재배치가 많거나 세그먼트로 분할할 경우에 적합한 주소 지정 방식
    - 유효 번지 = Base Register + 주소 부분(Operand)