태그: #정보처리기사
연결문서: [객체지향 기술 5](객체지향%20기술%205.md)

# 03. 자바(Java)

## 06. 접근 지정자(접근 제어자)

### 1) 접근 지정자의 이해
- 클래스 내에 멤버(변수, 메소드)의 접근을 제한하기 위한 예약어

<br>

### 2) 접근 지정자의 종류
1. private
    - 외부 객체에서 사용할 수 없고, 자신의 클래스에서만 사용 가능함
    - 가능한 모든 접근은 private로 선언하여 정보 은폐를 권장함
    - private 사용이 많으면 그만큼 부작용이 최소화됨
    - 멤버 변수 접근은 멤버 메소드로 사용하여 접근하도록 함
2. default(생략 시)
    - 하위 클래스나 다른 패키지에서는 사용할 수 없고, 자신의 클래스와 같은 패키지에서 사용할 수 있음
    - 가능한 생략하지 말고 접근 지정자를 선언하여 사용함
3. protected
    - 다른 패키지에서 사용할 수 없고, 자신의 클래스와 같은 패키지, 하위 클래스에서 사용할 수 있음
4. public
    - 모든 객체에서 사용할 수 있으며, 가능한 사용하지 않는 것을 원칙으로 함
    - public의 사용이 많으면 부작용이 많아짐

| &nbsp;&nbsp;구분&nbsp;&nbsp; | &nbsp;&nbsp;private&nbsp;&nbsp; | &nbsp;&nbsp;default&nbsp;&nbsp; | &nbsp;&nbsp;protected&nbsp;&nbsp; | &nbsp;&nbsp;public&nbsp;&nbsp; |
| :-: | :-: | :-: | :-: | :-: |
| &nbsp;&nbsp;자신의 클래스&nbsp;&nbsp; | &nbsp;&nbsp;○&nbsp;&nbsp; | &nbsp;&nbsp;○&nbsp;&nbsp; | &nbsp;&nbsp;○&nbsp;&nbsp; | &nbsp;&nbsp;○&nbsp;&nbsp; |
| &nbsp;&nbsp;같은 패키지&nbsp;&nbsp; | &nbsp;&nbsp;X&nbsp;&nbsp; | &nbsp;&nbsp;○&nbsp;&nbsp; | &nbsp;&nbsp;○&nbsp;&nbsp; | &nbsp;&nbsp;○&nbsp;&nbsp; |
| &nbsp;&nbsp;하위 클래스&nbsp;&nbsp; | &nbsp;&nbsp;X&nbsp;&nbsp; | &nbsp;&nbsp;X&nbsp;&nbsp; | &nbsp;&nbsp;○&nbsp;&nbsp; | &nbsp;&nbsp;○&nbsp;&nbsp; |
| &nbsp;&nbsp;다른 패키지&nbsp;&nbsp; | &nbsp;&nbsp;X&nbsp;&nbsp; | &nbsp;&nbsp;X&nbsp;&nbsp; | &nbsp;&nbsp;X&nbsp;&nbsp; | &nbsp;&nbsp;○&nbsp;&nbsp; |

<br>

---

<br>

## 07. 오버로딩과 오버라이딩

### 1) 오버로딩(Overloading)
- 하나의 클래스 안에서 동일한 이름을 가진 메소드를 사용하는 기술
- 메소드 이름은 같고, 메소드의 인수 개수, 유형이 다르면 오버로딩이 가능함

<br>

### 2) 오버라이딩(Overriding)
- 추상 클래스에서 동일한 메소드명과 인수를 정의해주면, 메소드 안의 프로그램은 상속 받은 클래스에서 다양하고 독립적으로 프로그래밍을 할 수 있도록 한다는 개념
- 상위 클래스의 메소드를 하위 클래스로 상속 받아 사용하다가 어느 시점에서는 그 메소드의 세부적인 기능이나 특징은 프로그래머 스스로에게 맡긴다는 의미
- 상위 클래스에서 정의된 메소드의 기능은 무시하고 새롭게 정의된 메소드를 사용한다고 해서 메소드 오버라이딩이라고 함
- 오버라이딩된 메소드는 메소드명과 인수는 반드시 일치해야 함
- 오버라이딩된 메소드는 상위 클래스의 메소드는 정보가 은폐되고 하위 클래스의 메소드를 사용하게 됨

<br>

---

<br>

## 08. 추상 클래스(Abstract Class)

### 1) 추상 클래스 사용 목적
- 비슷한 형태의 클래스를 여러 개 정의하여 사용할 경우 클래스를 보다  체계적으로 설계하기 위하여 사용함
- 도형의 면적을 구하는 메소드를 동일한 메소드명으로 접근할 수 있도록 도형 클래스를 설계하고, 내부에 면적과 출력 메소드를 선언했을 때, 도형 클래스에서 원, 삼각형, 사각형 클래스를 오버라이딩해서 구체적으로 기술하여 사용하면 다형성을 제공받을 수 있음
- 도형 클래스에서 상속 받은 클래스들은 반드시 면적, 출력 메소드를 사용하라고 해도 도형 클래스를 상속 받아 사용하는 하위 클래스들이 해당 메소드를 정의하지 않을 수도 있는데, 이때 강제성을 부여하기 위해서 추상 클래스를 선언함

<br>

### 2) 추상 클래스의 설계 방법
- 클래스들 사이에 공통적으로 사용하는 속성과 메소드를 추상 클래스로 선언함
    - 메소드의 몸체가 없이 메소드명만 정의하는 메소드
    - 프로그램 설계 시 모델링 개념의 메소드
    - 반드시 오버라이딩 되어야 사용이 가능함
- 추상 클래스를 상속 받는 하위 클래스를 정의함
- 하위 클래스는 정의하는 순간 공통적으로 사용하는 속성과 메소드는 오버라이딩됨

<br>

### 3) 추상클래스의 특징
- 추상 클래스는 인스턴스 객체를 생성할 수 없음
- 객체를 생성(new)할 수 없는 것을 제외하면 일반 클래스와 동일함
- 단, 추상 클래스를 타입의 객체 변수로 사용할 수 있음
    - 객체 변수는 객체가 아니고 객체를 가리키는 변수이기 때문

<br>

---

<br>

## 09. Java의 오류 처리

### 1)  try~catch~finally 절의 목적
- 프로그램 실행 중 심각한 오류가 발생하면, 실행 중인 프로그램은 스스로 해결하지 못하므로 프로그램은 종료되고 운영체제가 해결함
- Java 언어에서는 try~catch~finally절의 기능을 이용하여 심각한 오류가 발생하게 되면 운영체제에게 제어권을 넘기는 것이 아니라 스스로 해결하여 프로그램이 종료되지 않도록 함

<br>

### 2) try~catch~finally절의 구조 및 사용 방법
1. try 영역
    - 심각한 오류가 발생할 만한 프로그램 영역으로, 프로그램을 코딩할 때 문제가 있을 법한 곳의 범위를 지정함
2. catch 영역
    - 심각한 오류가 발생하면 처리하는 영역으로, try 영역에서 심각한 오류가 발생하면 모든 제어권이 운영체제로 넘어가지 않도록 하고 finally 영역 끝으로 제어권을 넘겨줌
    - 이때 오류 메시지를 직접 코딩할 수 있고, Java 시스템에서 제공하는 오류 메시지를 이용할 수도 있음
3. finally 영역
    - 마무리 영역으로 생략될 수 있음
    - 오류 유무와 상관없이 항상 실행되는 영역
    - 오류 발생 시에 오류 정보를 기록하거나 마무리 작업을 하는 용도로 사용

<br>

---

<br>

## 10. JavaScript Prototype

### 1) 프로토타입(Prototype)의 이해
- JavaScript(자바스크립트)는 Java 언어와 같이 클래스의 개념이 없으므로 상속의 개념을 사용하지 않음
- JavaScript는 기존의 객체를 복사해서 사용하는 객체기반 언어
- JavaScript에서 기존의 클래스와 상속의 개념을 사용하기 위해 특별한 프로토타입 속성을 추가하여 상속의 개념을 이용하는 것
- JavaScript의 프토로타입은 Prototype Object와 Prototype Link로 활용됨

<br>

### 2) Prototype Object와 Prototype Link
1. Prototype Object
    - 자신을 통해 만들어질 객체의 원형을 의미함
    - 객체를 위한 함수가 생성될 때 생성됨
    - 일반적인 객체와 동일하게 사용되므로 속성을 마음대로 추가/삭제/변경할 수 있음
    - JavaScript에서 객체를 생성하고, 프로토타입 속성으로 메소드를 정의해서 사용하는 방법
2. Prototype Link
    - 자신을 만들어낸 객체의 원형을 의미함
    - &#95;proto&#95; 속성을 이용하는 것
    - 객체 인스턴스가 생성될 때 &#95;proto&#95; 속성이 생성됨
    - 모든 객체는 &#95;proto&#95; 속성을 가지며 이 속성을 통해 Prototype Object의 속성을 변경할 수 있음
    - 부모 생성자를 호출하지 않으면서 Prototype Object를 공유할 수 있음