태그: #정보처리기사
연결문서: [애플리케이션 설계 6](애플리케이션%20설계%206.md)

# 소프트웨어 아키텍처
## 03. 소프트웨어 아키텍처 모델
### 1) 계층화 패턴(Layered Pattern)
#### 1. 기능을 분리한 계층(Layer)
- 하위 모듈들의 그룹으로 나눌 수 있는 구조화된 프로그램에서 사용할 수 있음
- 서비스 지향 아키텍처 기반 애플리케이션을 구성하는 계층은 다음과 같음
    - 표현 계층(Presentation Layer)
    - UI 계층(UI Layer)
    - 프로세스 계층(Process Layer)
    - 서비스 계층(Service Layer)
    - 비즈니스 논리 계층(Business Logic Layer)
    - 도메인 계층(Domain Layer)
    - 데이터 접근 계층(Data Access Layer)
    - 영속 계층(Persistence Layer)

#### 2. n-Tier(티어) 패턴
- Layer(계층)는 기능 집단을 논리적으로 분리하는 것이고, Tier는 기능 집단을 물리적으로 분리하는 것
- 1-Tier(티어)
    - 3가지 기능(데이터 관리, 통신 관리, 회사 업무 관리)을 한 클라이언트 서버 컴퓨터에 설치, 운영하는 경우(종속적)
- 2-Tier(티어)
    - 데이터베이스는 서버 컴퓨터에 나머지 2개는 클라이언트 컴퓨터에 분리하는 경우
- 3-Tier(티어)
    - 3개의 컴퓨터 시스템에 기능을 각각 분리시켜 운영하는 경우(독립적)
    
<br>

### 2) 클라이언트/서버 패턴(Client/Server Pattern)
- 분산 네트워크 시스템으로, 하나의 서버와 여러 개의 클라이언트로 구성
- 클라이언트가 서버에 서비스를 요청하면 서버는 클라이언트에게 서비스를 제공
- Email, 문서 공유, 은행 등에서 활용
- 장점 : 병목 현상을 줄일 수 있고, 결합력을 약하게 가질 수 있음
- 단점 : 보안이 취약하고 응용 프로그램이 복잡할 수 있음

<br>

### 3) 마스터/슬레이브 패턴(Master/Slave Pattern)
- 마스터(주인)가 슬레이브(하인)에게 작업을 분산하면, 슬레이브가 처리한 결과로 최종 결과를 계산하는 패턴
- 마스터 데이터베이스는 원본 데이터를 가지고 있고, 슬레이브는 복제본(Replication)을 동기화하는 형태로 활용할 수 있음
- 실시간 시스템에 적용할 수 있지만 마스터와 슬레이브 간에 Latency 문제가 발생할 수 있음
    - Latency
        - 자극과 반응 시간의 시간, 지체 시간, 지연 시간으로 해석됨
        - 슬레이브에서 마스터가 지시한 작업이 완성되기도 전에 마스터가 새로운 작업을 지시할 때 발행
        - 슬레이브에서는 마스터에서 작업이 완성되지 않았으니 기다리라고 신호를 발생하게 되므로 지체되는 시간이 발생하는 것
- 마스터/슬레이브의 역할
    - 마스터는 연산, 통신, 조정을 책임짐
    - 마스터는 슬레이브 프로세스들을 제어
    - 마스어튼 작업을 분리하고 슬레이브에게 분리한 작업을 분배하고, 결과를 계산하는 역할을 함
    - 슬레이브 프로세스들은 마스터가 요청한 작업만을 수행
    - 슬레이브는 마스터의 작업 요청을 처리하고, 처리된 결과를 되돌려줌
    - 슬레이브가 독립적이므로 공유되는 상태가 존재하지 않음

<br>

### 4) 파이프-필터 패턴(Pipe-filter Pattern)
- 데이터 스트림을 생성하고 처리하는 시스템에서 사용
- 서브 시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복
- 처리 과정은 필터(Filter)를 통해 이루어지며, 처리되는 데이터 스트림은 파이프(Pipe)를 통해 흐름
- 파이프는 버퍼링 또는 동기화 목적으로 사용될 수 있음
- 컴파일러, 연속한 필터들은 어휘 분석, 파싱 등에 활용

<br>

### 5) 브로커 패턴(Broker Pattern)
- 분산 시스템에서 사용
- 원격 서비스 실행을 통해 상호 작용을 함
- 브로커(Broker)는 컴포넌트 간의 통신을 조정하는 역할을 함
- 서버는 자신의 기능들을 브로커에 넘겨주며, 클라이언트가 브로커에 서비스를 오쳥하면 브로커는 자신이 보관하고 있는 기능들을 클라이언트에게 서비스함
- 웹 서버, 메시지 브로커 모듈 등에 활용할 수 있음

<br>

### 6) 피어 투 피어 패턴(Peer-to-peer Pattern)
- 피어(Peer)는 하나의 서버 또는 클라이언트일 수 있음
- 피어(Peer)는 또 다른 피어(Peer)에게 서비스를 요청할 수도 있고, 서버로서 각 피어에게 서비스를 제공할 수도 있음
- 피어는 언제든지 역할이 유동적으로 바뀔 수 있음
- 파일 공유 네트워크 등에 활용될 수 있음

<br>

### 7) 이벤트-버스 패턴(Event-bus Pattern)
- 알림 서비스 등에 활용
- 이벤트를 처리하는 4가지 주요 컴포넌트를 가짐
    - 이벤트 소스(Event Source) : 처리 결과나 데이터
    - 이벤트 리스너(Event Listener) : 특정 채널의 메시지를 구독
    - 채널(Channel) : 서버, 클라이언트, 컴포넌트
    - 이벤트 버스(Event Bus) : 메시지 경로
    
<br>

### 8) MVC 패턴(Model-View-Controller Pattern)
#### 1. MVC 패턴의 개념
- 사용자 인터페이스로부터 비즈니스 로직을 분리하여 응용 프로그램의 시각적인 요소를 비즈니스 로직의 변화에 영향 없이 쉽게 수정할 수 있도록 지원
- 인터페이스가 변경에 영향을 덜 받도록 만든 모델
- 여러 개의 서브 시스템을 사용하는 경우에 적합한 환경
- 웹 애플리케이션 등에 활용
- MVC 패턴은 Model, View, Controller로 구성

#### 2. Model(모델)
- 응용 프로그램의 데이터를 나타냄
- 인터페이스에 영향을 받지 않으며 요청한 데이터 처리를 담당
- 모델 상태의 변화가 있을 경우, 모델은 컨트롤러와 뷰에 통보하기 때문에 뷰는 최신의 정보를 사용할 수 있음
- 컨트롤러가 직접 모델에서 정보를 가져올 수 있음

#### 3. View(뷰)
- 사용자에게 데이터를 보여주는 부분
- 입력 텍스트, 체크 박스 등과 같은 사용자 인터페이스 요소
- 뷰는 사용자가 사용할 결과물을 생성하기 위해 모델로부터 데이터를 가져옴

#### 4. Controller(컨트롤러)
- 데이터와 비즈니스 로직 사이의 상호 동작을 관리
- 뷰를 통한 사용자 요청을 해당 모델에게 전달하고, 모델에게 받은 응답을 다시 사용자에게 돌려주는 역할
- 컨트롤러는 모델의 변화에 따른 적용 가능한 명령을 추가, 삭제, 수정할 수 있음

<br>

### 9) 블랙보드 패턴(Blackboard Pattern)
- 3가지 주요 컴포넌트로 구성
    - 블랙보드(Blackboard) : 소스 저장 메모리
    - 지식 소스(Knowledge Source) : 특정 데이터, 블랙보드에 저장된 데이터
    - 제어 컴포넌트(Control Component) : 모듈 선택, 설정 및 실행 담당
- 모든 컴포넌트는 블랙보드로 접근하여 소스를 저장
- 제어 컴포넌트는 블랙보드에 추가되는 새로운 데이터를 생성
- 제어 컴포넌트는 블랙보드에서 기존 지식 소스와의 패턴 매칭으로 특정 데이터를 찾음
- 음성 인식, 차량 식별 및 추적 등에 활용

<br>

### 10) 인터프리터 패턴(Interpreter Pattern)
- 특정 언어나 명령어를 해석하는 컴포넌트를 설계할 때 사용
- 특정 언어로 작성된 문장 혹은 표현식이라고 하는 프로그램의 각 라인을 수행하는 방법을 지정
- SQL의 쿼리 언어 등에 활용