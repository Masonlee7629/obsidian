태그: #정보처리기사
연결문서: [물리 데이터베이스 설계 1](물리%20데이터베이스%20설계%201.md)

# 05. 병행 제어와 로킹

## 01. 병행 제어

### 1) 병행 제어(Concurrency Control, 동시성 제어)의 목적
- 여러 사용자들이 데이터베이스의 공동 사용을 최대화함
- 사용자의 응답 시간을 최소화함
- 데이터베이스 시스템의 활용도를 최대화함
- 데이터베이스의 일관성을 유지함

<br>

### 2) 병행 처리의 문제점
1. 분산된 갱신(Lost update)
    - 두 개의 트랜잭션이 있을 때 같은 데이터에 대해서 한 개의 트랜잭션 작업이 갱신 작업이고 또 하나의 트랜잭션이 역시 같은 데이터에 대해서 갱신 작업이라고 했을 때 하나의 작업이 분실되는 현상이 벌어지는 경우
2. 모순성(Inconsistency)
    - 두 개의 트랜잭션이 있을 때 같은 데이터에 대해서 한 개의 트랜잭션 작업이 갱신 작업을 하고 있는 상태에서 또 하나의 트랜잭션이 침범하여 갱신하게 되면 두 개의 트랜잭션이 모두 끝나게 되더라도 그 데이터에 대한 결과는 사용자가 원하는 결과와 일치하지 않는 상태가 되어, 데이터베이스의 일관성을 해치는 경우
3. 연쇄 복구(Cascading Rollback)
    - 두 개의 트랜잭션이 있을 때 같은 데이터에 대해서 갱신을 실시하는 과정에서 한 개의 트랜잭션은 성공적으로 일을 수행하였다 하더라도 다른 한 개의 트랜잭션이 처리하는 과정에서 실패하게 되면 잘못된 데이터에 접근했다는 이유로 두 개의 트랜잭션 모두가 복귀되는 현상이 벌어지는 경우
4. 비완료 의존성(Uncommitted Dependency)
    - 한 개의 트랜잭션이 실패하였을 때, 이 트랜잭션이 회복하기 전에 다른 트랜잭션이 실패한 수행 결과를 참조하는 경우

<br>

### 3) 병행 제어 기법
- 로킹(Locking) : 데이터베이스에서 하나의 트랜잭션에 사용하는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는 행위
- 2단계 로킹 규약(Two-Phase Locking Protocol)
    - 확장 단계 : 새로운 Lock은 가능하고 Unlock은 불가능함
    - 축소 단계 : Unlock은 가능하고 새로운 Lock은 불가능함(교착 상태가 발생함)
- 타임스탬프(Time Stamp) : 데이터베이스에 접근하는 시간을 미리 정하고, 정해진 시간의 순서대로 데이터베이스에 접근하게 함(교착 상태가 발생하지 않음)
- 낙관적 병행 제어(Optimistic Concurrency Control) : 트랜잭션 수행 동안은 어떠한 작업을 하지 않고, 트랜잭션 종료 시에 일괄적으로 체크하여 데이터베이스에 접근하게 함
- 다중 버전 병행 제어(Multi-version Concurrency Control) : 여러 버전의 타임스탬프를 비교, 선택하여 데이터베이스에 접근하게 하고, 충돌이 발생할 경우 복귀(Rollback)를 수행함

<br>

---

<br>

## 02. 로킹(Locking)

### 1) 로킹의 목적
- 데이터베이스에서 하나의 트랜잭션에 사용하는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는 행위
- 로킹의 단위는 얼마만큼 큰 단위로 로크(Lock)를 소유하고 풀어줄 것인가에 따라 데이터베이스 성능에 영향을 미침
- 일정한 크기의 데이터베이스 공유 영역을 적절한 크기로 분할한 영역을 로킹 단위라고 하며, 로킹 단위가 크면 로크의 수가 줄어들어 병행 제어 기술이 단순해지며 병행성 수준이 낮아짐

<br>

### 2) 로킹 단위 크기에 따른 비교

|      &nbsp;&nbsp;구분&nbsp;&nbsp;      | &nbsp;&nbsp;큰 로크의 단위&nbsp;&nbsp; | &nbsp;&nbsp;작은 로크의 단위&nbsp;&nbsp; |
|:--------------------------------------:|:--------------------------------------:|:----------------------------------------:|
|   &nbsp;&nbsp;로크의 수&nbsp;&nbsp;    |     &nbsp;&nbsp;작아짐&nbsp;&nbsp;     |      &nbsp;&nbsp;많아짐&nbsp;&nbsp;      |
| &nbsp;&nbsp;병행 제어 기법&nbsp;&nbsp; |     &nbsp;&nbsp;단순함&nbsp;&nbsp;     |      &nbsp;&nbsp;복잡함&nbsp;&nbsp;      |
|  &nbsp;&nbsp;병행성 수준&nbsp;&nbsp;   |     &nbsp;&nbsp;낮아짐&nbsp;&nbsp;     |      &nbsp;&nbsp;높아짐&nbsp;&nbsp;      |
|    &nbsp;&nbsp;오버헤드&nbsp;&nbsp;    |     &nbsp;&nbsp;감소함&nbsp;&nbsp;     |      &nbsp;&nbsp;증가함&nbsp;&nbsp;      |

<br>

---

<br>

## 03. 회복(Recovery)

### 1) 회복(Recovery)
- 어떤 외부적인 장애 요인이나 내부적인 장애 요인에 의해서 데이터베이스의 상태가 일관성 유지에 제약이 걸렸을 때 장애 이전의 일관된 상태가 되도록 복원하는 일

<br>

### 2) 장애의 유형
1. 트랜잭션 장애(Transaction Failure)
    - 트랜잭션 내의 논리적 오류로 잘못된 입력, 데이터 발견 불가능, 오버플로우, 자원 한계 초과 등과 같은 내부 조건으로 인하여 트랜잭션이 더 이상 정상적인 실행을 할 수 없는 상태를 의미
2. 시스템 장애(System Failure)
    - 하드웨어 오작동으로 인하여 휘발성 기억 장치의 내용이 유실되거나 교착 상태로 인하여 더 이상 정상적 실행을 할 수 없는 상태를 의미
3. 미디어 장애(Media Failure)
    - 데이터 전송 중에 헤드 충격이나 고장으로 인하여 디스크 등이 작동하지 못하는 상태를 의미

<br>

### 3) 회복에 따른 연산자
- 회복 Redo
    - 갱신이 완료된 데이터를 로그를 이용해 데이터베이스에 적용하는 연산으로 주로 데이터베이스의 내용이 손상됐을 때, Backup 본으로 회복한 다음 Backup 본에 있는 데이터 이후는 로그에 갱신되어 있는 데이터를 데이터베이스에 적용하는 데 사용함
- 회복 Undo
    - 변경된 데이터를 취소하여 원래의 내용으로 복원시키는 연산으로 주로 트랜잭션 실행 중 실행이 실패하였을 경우 원래의 내용으로 복원하는 경우에 사용함

<br>

### 4) 회복 기법
1. 즉시 갱신을 로그를 이용한 회복
    - 트랜잭션이 일을 하고 있는 상태에서 그 결과를 즉시 데이터베이스에 반영할 수 있도록 하는 방법
    - 트랜잭션의 처리 도중 어떤 장애 요인에 의해서 트랜잭션이 완료되지 못한다면 로그에 있는 갱신 이전의 데이터로 데이터베이스를 복원하여 회복하는 기법(Undo 연산)
2. 로그를 이용한 지연 회복 기법
    - 어떤 트랜잭션의 갱신 결과를 로그에 기록하여 두었다가 트랜잭션의 연산이 완료되면 한 번에 데이터베이스에 반영하는 기법(Redo 연산)
3. 검사 시점에 의한 회복 기법
    - 장애 요인이 발생했을 때 로그에 있는 데이터 중 어디까지 데이터베이스에 반영해야 하는지를 결정하는 방법
    - Checkpoint라는 검사점을 두고, 로그에 있는 내용이 데이터베이스에 반영될 때마다 이 검사점을 설정한 다음, 장애 요인 발생 시 최근의 검사점을 찾아 검사점 이전은 Redo 연산을, 이후는 Undo 연산을 실시하여 데이터베이스에 반영하는 방법
    - 쓸데없는 부가적 노력을 방지하는 데 목적이 있음
4. 그림자 페이징(Shadow Paging) 기법
    - 로그를 이용하지 않고 데이터베이스를 일정 크기의 페이지 단위인 현 페이지 테이블과 그림자 페이지 테이블을 유지하면서 데이터 변경 시 현 페이지 테이블만 변경시키고 그림자 페이지는 이전의 값을 유지함
    - 문제 발생 시 그림자 페이지로 대체하여 회복하는 기법을 의미