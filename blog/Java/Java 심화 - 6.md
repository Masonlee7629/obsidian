태그: #Java 

# Java 심화

## 자바 가상 머신(Java Virtual Machine)

JVM은 자바 프로그램을 실행시키는 도구이다. 즉, JVM은 자바로 작성한 소스 코드를 해석해 실행하는 별도의 프로그램이다.

자바는 운영체제로부터 독립적이고, 자바의 독립성은 JVM을 통해 구현되는데, 이유는 다음과 같다.

먼저 프로그램이 실행되기 위해서는 CPU, 메모리, 각종 입출력 장치 등과 같은 컴퓨터 자원을 프로그램이 할당받아야 한다.

프로그램이 자신이 필요한 컴퓨터 자원을 운영체제에게 주문하면, 운영체제는 가용한 자원을 확인한 다음, 프로그램이 실행되는 데에 필요한 컴퓨터 자원을 프로그램에게 할당해준다.

이 때, 프로그램이 운영체제에게 필요한 컴퓨터 자원을 요청하는 방식이 운영체제마다 다르다. 이것이 프로그래밍 언어가 운영체제에 대해 종속성을 가지게 되는 이유이다.

하지만 자바는 JVM을 매개해서 운영체제와 소통한다. 즉, JVM이 자바 프로그램과 운영체제 사이에서 일종의 통역가 역할을 수행한다.

JVM은 각 운영체제에 적합한 버전이 존재한다. 즉, Window용 JVM, Mac OS용 JVM, Linux용 JVM이 따로 존재한다.

이처럼 운영체제에 맞게 JVM이 개밸되어져 있으며, JVM은 자바 소스 코드를 운영 체제에 맞게 변환해 실행시켜준다. 이것이 자바가 운영체제로부터 독립적으로 동작할 수 있는 이유이다.

[##_Image|kage@neeZN/btsakdXaduY/F8lkkYy2CpnJ8wXbuqFCRK/img.png|CDM|1.3|{"originWidth":900,"originHeight":560,"style":"alignCenter"}_##]

### JVM 구조

[##_Image|kage@cl8bGs/btsbk6C6Nao/Czep3C27tl7GkEW0UINXJK/img.png|CDM|1.3|{"originWidth":1920,"originHeight":1080,"style":"alignCenter","width":null}_##]

자바로 소스 코드를 작성하고 실행하면, 먼저 컴파일러가 실행되면서 컴파일이 진행된다. 컴파일의 결과로 .java 확장자를 가졌던 자바 소스 코드가 .class 확장자를 가진 바이트 코드 파일로 변환된다.

이후, JVM은 운영체제로부터 소스 코드 실행에 필요한 메모리를 할당받는다. 그것이 위 그림 상의 런타임 데이터 영역(Runtime Data Area)이다.

그 다음에는 클래스 로더(Class Loader)가 바이트 코드 파일을 JVM 내부로 불러들여 런타임 데이터 영역에 적재시킴으로써 자바 소스 코드를 메모리에 로드시킨다.

로드가 완료되면 실행 엔진(Execution Engine)이 런타임 데이터 영역에 적재된 바이트 코드를 실행시킨다.

이 때, 실행 엔진은 두 가지 방식으로 바이트 코드를 실행시킨다.

1.  인터프리터(Interpreter)를 통해 코드를 한 줄씩 기계어로 번역하고 실행시키기
2.  JIT Compiler(Just-In-Time Compiler)를 통해 바이트 코드 전체를 기계어로 번역하고 실행시키기

실행 엔진은 기본적으로 1번의 방법을 통해 바이트 코드를 실행시키다가, 특정 바이트 코드가 자주 실행되면 해당 바이트 코드를 JIT Compiler를 통해 실행시킨다.

즉, 중복적으로 어떤 바이트 코드가 등장할 때, 인터프리터는 매 번 해당 바이트 코드를 해석하고 실행하지만, JIT 컴파일러가 동작하면 한 번에 바이트 코드를 해석하고 실행시킨다.

### Stack과 Heap

#### JVM 메모리 구조

[##_Image|kage@elWKkD/btsaipKx3ab/aDK8JLVG7PsTQZbjMaFadk/img.png|CDM|1.3|{"originWidth":1080,"originHeight":300,"style":"alignCenter"}_##]

JVM에 Java 프로그램이 로드되어 실행될 때 특정 값 및 바이트 코드, 객체, 변수 등과 같은 데이터들이 메모리에 저장되어야 한다. 런타임 데이터 영역이 바로 이런 정보를 담는 메모리 영역이며, 크게 5가지 영역으로 구분되어 있다.

Heap과 Stack은 5가지 영역에 포함되어 있다.

#### Stack 영역

스택은 일종의 자료구조이다. 자료구조는 프로그램이 데이터를 저장하는 방식을 의미하며, 간략히 말하자면 저장 방식 중 하나가 스택이라고 할 수 있다.

스택은 흔히 LIFO라는 키워드로 설명된다. LIFO는 "Last In First Out"의 약자로, 마지막에 들어간 데이터가 가장 먼저 나온다는 의미이며, 스택의 데이터 입출력 순서를 나타내는 원칙이다.

JVM안에서 Stack은 메서드가 호출되면 그 메서드를 위한 공간인 Method Frame이 생성된다. 메서드 내부에서 사용하는 다양한 값들이 있는데 참조변수, 매개변수, 지역변수, 리턴값 및 연산 시 일어나는 값들이 임시로 저장된다.

이런 Method Frame이 Stack에 호출되는 순서대로 쌓이게 되는데, Method의 동작이 완료되면 역순으로 제거된다.

#### Heap 영역

JVM에는 단 하나의 Heap 영역이 존재한다. JVM이 작동되면 이 영역은 자동 생된단다. 그리고 이 영역 안에 객체나 인스턴스 변수, 배열이 저장된다.

```
Person person = new Person();
```

위의 new Person()이 실행되면 Heap 영역에 인스턴스가 생성되며, 인스턴스가 생성된 위치의 주소값을 person에게 할당해주는데, 이 person은 Stack 영역에 선언된 변수이다.

즉, 객체를 다룬다는 것은 Stack 영역에 저장되어 있는 참조 변수를 통해 Heap 영역에 존재하는 객체를 다룬다는 의미로, Heap 영역은 실제 객체의 값이 저장되는 공간이다.

### Garbage Collection

자바에서는 가비지 컬렉션이라는 메모리를 자동으로 관리하는 프로세스가 포함되어 있다. 가비지 컬렉션은 프로그램에서 더 이상 사용하지 않는 객체를 찾아 삭제하거나 제거하여 메모리를 확보하는 것을 의미한다.

가비지 컬렉터는 참도죄고 있지 않은 객체 및 변수들을 검색하여 메모리에서 점유를 해제하며, 메모리 공간을 확보하여 효율적으로 메모리를 사용할 수 있게 해준다.

#### 동작 방식

JVM의 Heap 영역은 객체는 대부분 일회성이며, 메모리에 남아 있는 기간이 대부분 짧다는 전제로 설계되어 있다. 그렇게 때문에 객체가 얼마나 살아있냐에 따라서 Heap 영역 안에서도 영역을 나누게 되는데 Young, Old 영역 이렇게 두 가지로 나뉜다.

[##_Image|kage@brAUYW/btsaEScE3oU/9egtkkb7DLgxIfBO5kAPNk/img.png|CDM|1.3|{"originWidth":1080,"originHeight":300,"style":"alignCenter"}_##]

Young 영역은 새롭게 생성된 객체가 할당되는 곳이고, 여기에는 많은 객체가 생성되었다 사라지는 것을 반복한다.

이 영역에서 활동하는 가비지 컬렉터를 **Minor GC**라고 부른다.

Old 영역은 Young 영역에서 상태를 유지하고 살아남은 객체들이 복사되는 곳으로 보통 Young 영역보다 크게 할당되고 크기가 큰 만큼 가비지는 적게 발생한다.

이 영역에서 활동하는 가비지 컬렉터를 **Major GC**라고 부른다.

Young 영역과 Old 영역은 서로 다른 메모리 구조로 되어 있기 때문에 세부적인 동작 방식은 다르지만 기본적으로 가비지 컬렉션이 실행될때는 다음의 두 가지 단계를 따른다.

1.  Stop The World  
    Stop The World는 가비지 컬렉션을 실행시키기 위해 JVM이 애플리케이션의 실행을 멈추는 작업이다.
2.  가비지 컬렉션이 실행될 때 가비지 컬렉션을 실행하는 스레드를 제외한 모든 스레드들의 작업은 중단되고, 가비지 정리가 완료되면 재개된다.
3.  Mark and Sweep  
    Mark는 사용되는 메모리와 사용하지 않는 메모리를 식별하는 작업을 의미하며, Sweep은 Mark단계에서 사용되지 않음으로 식별된 메모리를 해체하는 작업을 의미한다.

즉, Stop The World를 통해 모든 작업이 중단되면, 가비지 컬렉션이 모든 변수와 객체를 탐색해서 각각 어떤 객체를 참고하고 있는지 확인한다.

이후, 사용되고 있는 메모리를 식별해서(Mark) 사용되지 않는 메모리는 제거(Sweep)하는 과정을 진행한다.