태그: #Spring 

#  JWT(Json Web Token) 개요

## 토큰 기반 자격 증명
- HTTP 프로토콜은 request를 전송한 후, response를 수신하게 되면 연결을 끊는 비 연결성(Connectionless)의 특성을 가지고 있고 또한 request와 response에 대한 상태를 저장하지 않는 비 상태성(Stateless)의 특성이 있기 때문에 로그인 인증이 성공적으로 수행되었다 하더라도 서버 측에서는 매번 request를 수신할 때마다 이 request가 인증된 사용자가 보낸 request인지 알 방법이 없음
- 이러한 HTTP 특성으로 인해 사용자의 인증이 성공적으로 이루어졌을 때, 인증된 사용자 request의 상태를 유지하기 위한 수단이 필요하게 되었으며 대표적인 수단으로 세션이 있음

<br>

### 세션 기반 자격 증명 방식

#### 세션 기반 자격 증명의 특징
- 세션은 인증된 사용자 정보를 서버 측 세션 저장소에서 관리함
- 생성된 사용자 세션의 고유 ID인 세션 ID는 클라이언트의 쿠키에 저장되어 request 전송 시, 인증된 사용자인지를 증명하는 수단으로 사용됨
- 세션 ID만 클라이언트 쪽에서 사용하므로 상대적으로 적은 네트워크 트래픽을 사용함
- 서버 측에서 세션 정보를 관리하므로 보안성 측면에서 조금 더 유리함
- 서버의 확장성 면에서는 세션 불일치 문제가 발생할 가능성이 높음
- 세션 데이터가 많아질수록 서버의 부담이 가중될 수 있음
- SSR(Server Side Rendering) 방식의 애플리케이션에 적합한 방식

<br>

### 토큰 기반 자격 증명 방식

#### 토큰 기반 자격 증명의 특징
- 토큰에 포함된 인증된 사용자 정보는 서버 측에서 별도의 관리를 하지 않음
- 생성된 토큰을 헤더에 포함해 request 전송 시, 인증된 사용자인지를 증명하는 수단으로 사용됨
- 토큰 내에 인증된 사용자 정보 등을 포함하고 있으므로 세션에 비해 상대적으로 많은 네트워크 트래픽을 사용함
- 기본적으로 서버 측에서 토큰을 관리하지 않으므로 보안성 측면에서 조금 더 불리함
- 인증된 사용자 request의 상태를 유지할 필요가 없기 때문에 서버의 확장성 면에서 유리하고, 세션 불일치 같은 문제가 발생하지 않음
- 토큰에 포함되는 사용자 정보는 토큰의 특성상 암호화가 되지 않기 때문에 공격자에게 토큰이 탈취될 경우, 사용자 정보를 그대로 제공하는 셈이 되므로 민감한 정보는 토큰에 포함하지 말아야 함
- 기본적으로 토큰이 만료되기 전까지는 토큰을 무효화시킬 수 없음
- CSR(Client Side Rendering) 방식의 애플리케이션에 적합한 방식

<br>

---

<br>

## JWT(Json Web Token)란?
- JWT(JSON Web Token)는 데이터를 안전하고 간결하게 전송하기 위해 고안된 인터넷 표준 인증 방식으로써 토큰 인증 방식에서 가장 범용적으로 사용되며 JSON 포맷의 토큰 정보를 인코딩 후, 인코딩 된 토큰 정보를 Secret Key로 서명(Sign)한 메시지를 Web Token으로써 인증 과정에 사용함

<br>

### JWT의 종류
1. 액세스 토큰(Access Token)
    - Access Token은 보호된 정보들(사용자의 이메일, 연락처, 사진 등)에 접근할 수 있는 권한 부여에 사용함
    - 클라이언트가 처음 인증을 받게 될 때(로그인 시), Access Token과 Refresh Token 두 가지를 다 받지만, 실제로 권한을 얻는 데 사용하는 토큰은 Access Token
    - Access Token에는 비교적 짧은 유효 기간을 주어 탈취 되더라도 오랫동안 사용할 수 없도록 하는 것이 좋음
2. 리프레시 토큰(Refresh Token)
    - Access Token의 유효 기간이 만료된다면 Refresh Token을 사용하여 새로운 Access Token을 발급 받으며, 이때, 사용자는 다시 로그인 인증을 할 필요가 없음
    - 유효기간이 긴 Refresh Token을 악의적인 유저가 얻어낸다면 Refresh Token을 이용해 Access Token을 다시 발급 받을 수 있기 때문에 사용자에게 큰 피해를 입힐 수 있음
    - 사용자의 편의보다 정보를 지키는 것이 더 중요한 웹 애플리케이션은 Refresh Token을 사용하지 않는 곳이 많음

<br>

### JWT 구조

![](image_19.png)

<br>

1. Header
    - Header는 이것이 어떤 종류의 토큰인지(지금의 경우엔 JWT), 어떤 알고리즘으로 Sign할지 정의함
    - JSON Web Token이라는 이름에 걸맞게 JSON 포맷 형태로 정의함
    - 아래 JSON 객체를 base64 방식으로 인코딩하면 JWT의 첫 번째 부분이 완성됨

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

<br>

2. Payload
    - Payload에는 서버에서 활용할 수 있는 사용자의 정보가 담겨 있음
    - 어떤 정보에 접근 가능한지에 대한 권한을 담을 수도 있고, 사용자의 이름 등 필요한 데이터를 담을 수 있음
    - Payload는 Signature를 통해 유효성이 검증될 정보이긴 하지만, 민감한 정보는 담지 않는 것이 좋음
    - 아래 JSON 객체를 base64로 인코딩하면 JWT의 두 번째 블록이 완성됨

```json
{
  "sub": "someInformation",
  "name": "phillip",
  "iat": 151623391
}
```

<br>

3. Signature
    - Signature에서는 원하는 비밀 키(Secret Key)와 Header에서 지정한 알고리즘을 사용하여 Header와 Payload에 대해서 단방향 암호화를 수행함
    - 이렇게 암호화된 메시지는 토큰의 위변조 유무를 검증하는 데 사용됨
    - 만약 HMAC SHA256 알고리즘(암호화 방법 중 하나)을 사용한다면 Signature는 아래와 같은 방식으로 생성됨

```json
HMACSHA256(base64UrlEncode(header) + '.' + base64UrlEncode(payload), secret);
```

<br>

### 토큰 기반 인증 절차
1. 클라이언트가 서버에 아이디/비밀번호를 담아 로그인 요청을 보냄
2. 아이디/비밀번호가 일치하는지 확인하고, 클라이언트에게 보낼 암호화된 토큰을 생성함
    - Access Token과 Refresh Token을 모두 생성함
        - 토큰에 담길 정보(Payload)는 사용자를 식별할 정보, 사용자의 권한 정보 등이 될 수 있음
        - Refresh Token 이용해 새로운 Access Token을 생성할 것이므로 두 종류의 토큰이 같은 정보를 담을 필요는 없음
3. 토큰을 클라이언트에게 전송하면, 클라이언트는 토큰을 저장함
    - 저장하는 위치는 Local Storage, Session Storage, Cookie 등이 될 수 있음
4. 클라이언트가 HTTP Header(Authorization Header) 또는 쿠키에 토큰을 담아 request를 전송함
    - Bearer authentication을 이용함
5. 서버는 토큰을 검증하여 서버에서 발급해 준 토큰이라는 판단이 될 경우, 클라이언트의 요청을 처리한 후 응답을 보내줌

<br>

---

<br>

## JWT의 장점과 단점

### JWT를 통한 인증의 장점
1. 상태를 유지하지 않고(Stateless), 확장에 용이한(Scalable) 애플리케이션을 구현하기 용이함
    - 서버는 클라이언트에 대한 정보를 저장할 필요가 없음 (토큰이 정상적으로 검증되는지만 판단함)
    - 클라이언트는 request를 전송할 때마다 토큰을 헤더에 포함시키면 됨
        - 여러 대의 서버를 이용한 서비스라면 하나의 토큰으로 여러 서버에서 인증이 가능하기 때문에 JWT를 사용하는 것이 효과적
        - 만약에 세션 방식이라면 모든 서버가 해당 사용자의 세션 정보를 공유하고 있어야 함
2. 클라이언트가 request를 전송할 때마다 자격 증명 정보를 전송할 필요가 없음
    - HTTP Basic 같은 인증 방식은 request를 전송할 때마다 자격 증명 정보를 포함해야 하지만 JWT의 경우 토큰이 만료되기 전까지는 한 번의 인증만 수행하면 됨
3. 인증을 담당하는 시스템을 다른 플랫폼으로 분리하는 것이 용이함
    - 사용자의 자격 증명 정보를 직접 관리하지 않고, Github, Google 등의 다른 플랫폼의 자격 증명 정보로 인증하는 것이 가능함
    - 토큰 생성용 서버를 만들거나, 다른 회사에서 토큰 관련 작업을 맡기는 것 등 다양한 활용이 가능함
4. 권한 부여에 용이함
    - 토큰의 Payload(내용물) 안에 해당 사용자의 권한 정보를 포함하는 것이 용이함

<br>

### JWT를 통한 인증의 단점
1. Payload는 디코딩이 용이함
    - Payload는 base64로 인코딩 되기 때문에 토큰을 탈취하여 Payload를 디코딩하면 토큰 생성 시 저장한 데이터를 확인할 수 있기 때문에 Payload에는 민감한 정보를 포함하지 않아야 함
2. 토큰의 길이가 길어지면 네트워크에 부하를 줄 수 있음
    - 토큰에 저장하는 정보의 양이 많아질수록 토큰의 길이는 길어지며, request를 전송할 때마다 길이가 긴 토큰을 함께 전송하면 네트워크에 부하를 줄 수 있음
3. 토큰은 자동으로 삭제되지 않음
    - 한 번 생성된 토큰은 자동으로 삭제되지 않기 때문에 토큰 만료 시간을 반드시 추가해야 함
    - 토큰이 탈취된 경우 토큰의 기한이 만료될 때까지 토큰 탈취자가 해당 토큰을 정상적으로 이용할 수 있으므로 만료 시간을 너무 길게 설정하지 않아야 함